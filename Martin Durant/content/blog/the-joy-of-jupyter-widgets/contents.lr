title: The joy of jupyter widgets
---
author: Martin Durant
---
pub_date: 2018-11-23
---
twitter_handle: martin_durant_
---
body:

Since the start of this year, I have been involved with the [Intake](https://intake.readthedocs.io/en/latest/) project. Intake is all about how to describe and access data and building catalogs, but **this** article is about the GUI, which was built quickly with [jupyter widgets](https://ipywidgets.readthedocs.io/en/stable/) (formerly `ipywidgets`). 

## The need for a GUI

Without going into the details of Intake (please, read about it!), the need for a graphical interface alongside the programmatical one was recognised early on. The initial aim was to use [jupyter-lab,](https://jupyterlab.readthedocs.io/en/stable/), which is designed to allow for graphical/interactive panels alongside notebooks and interactive python sessions. However, extensions are written in typescript and require a build-and-deploy cycle to see the results of changes. I, to my shame, am no typescript programmer and I don't even know how the build system works, though doubtless I could begin [here](https://github.com/jupyterlab/extension-cookiecutter-ts)

## Jupyter Widgets to the rescue

Fortunately, jupyter-widgets is *really simple*: you can instantiate in a cell and render the interactive output immediately. Because the notebook already ensures that the kernel is running and sets up comms between front- and back-ends, the user interaction logic is wholly python-side.

```python
import ipywidgets
clicks = [0]
button = ipywidgets.Button(description='Click me!')

def action(*args):
    clicks[0] += 1

button.on_click(action)
button
```

An appropriate button appears, and clicks are nicely collected in the `clicks` variable. Given the existence of layouts with [flexible sizing](https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20Styling.html), where you can add and remove elements at will, this is starting to feel quite a lot like my [earlier experience](https://docs.anaconda.com/anaconda/navigator/) with PyQT. Sure, there is no formal message-passing mechanism, but for simple enough interfaces, you can get by. You can even employ CSS within the elements for detailed styling.

## Forward

The [resultant GUI](https://intake.readthedocs.io/en/latest/gui.html) is already very useful, and required [little code](https://github.com/ContinuumIO/intake/blob/master/intake/gui/widgets.py) to produce. It can yet be enhanced to do things like show a data extract or plots of the selected data-set, since you can embed other `display`-able elements or HTML such as produced by Bokeh.
Furthermore, the output can already be send to a separate panel in jupyter-lab using a [sidecar](https://github.com/jupyter-widgets/jupyterlab-sidecar).

However, there is no reason that this should be the only GUI for Intake. Come one, come all! If someone would like to help be typescript something for jupyter-lab, I would appreciate it, it would be nice to have a permanent data browser in the session not tied to a particular notebook.

Probably the rapidly developing [panel](https://panel.pyviz.org/user_guide/Widgets.html) library will be able to produce a similarly flexible interface which can be run within or without a notebook, and integrates more naturally with bokeh tabular and graphical output.

**Summary**: working with jupyter-widgets was remarkably smooth and easy, and I got to a useful, functional interface far faster than I had thought it would take.

<script data-goatcounter="https://md-blog.goatcounter.com/count" async src="//gc.zgo.at/count.js"/>

---
_discoverable: yes
